\section{QR Code - Connection}
The whole connections starts by making sure the user visits the link via. scanning the QR code.
Afterwards a link gets generated, that is unique for every session and contains a JWT token.
This token gets generated by the backend and send over to the front-end and only then the user may connect.
In that way, we make sure that no connection can be established without the user having the right to do so.
The front-end then uses this exact JWT token and only allows connections with the same token in current use.
Considering all previous steps, the actual connection logic is then handled by the users front-end, from which the device (e.g. phone) emits a ''register'' message to the backend.
This leads to the final step of the connection, where the backend receives the message and sends over the status that is appropriate for the current connection state.
If everything worked optimally the front-end gets the message ''connected'' emited from the backend. 
\subsection{Role \& Status}
First we have to define what actual roles can connect, this makes random or brute connections even harder.
Currently we have two roles, namely the ''client'' and ''host'' role.
The client is the one who connects to the host, whereas the host is the one who gives the opportunity connecting to the currently active session. \\ \\

To make sure a connection is actually valid we now discuss the part where we need to define different states helping us understanding what went pottentially wrong in a connection. \\
The following states currently in use are defined as:
\begin{itemize}
    \item \textbf{pending} - The QR Code is created and the front-end is waiting for the user to connect.
    \item \textbf{connected} - The user has successfully connected to the session and can now use the application as intended.
    \item \textbf{disconnected} - The user has disconnected from the session, either by closing the application or by a timeout.
    \item \textbf{already\_connected} - The user or a host was already connected to the backend, which moves potential intruders into a url sinkhole.
\end{itemize}
The states that should be added for a more detailed error handling are:
\begin{itemize}
    \item \textbf{no\_host} - The user tries to connect to a session that does not exist.
    \item \textbf{invalid\_role} - The user tries to connect with a role that does not exist.
\end{itemize}

\subsection{Registration}
Making the connection valid though, it is not enough to just scan the qr code.
We actually need a registration logic that makes sure that the host and client are allowed to connect.
This is done by the host front-end and clients front-end, who both need to emit a ''register'' message to the backend.
By registering, the backend recognizes if a host or client is already connected.
This makes flag handling easier, as the backend can then emit a message to the host or client front-end appropriate to the actual status.
If the user is in private mode, then we emit a special message called ''register-private'', 
which then creates a file with a unique uuid and a token in the local storage of the users browser.
This file and local storage token is only created though if the user submits his age and experience first.
Such a file would then look like this:
\begin{lstlisting}[language=json,firstnumber=1]
{
    "user_id": "abc123",
    "age": "< 18",
    "experience": 2,
    "progress": {}
}
\end{lstlisting}
Where the \textbf{user\_id} (String) is the unique identifier for the user, 
\textbf{age} (String) is the apporximate age of the user, 
\textbf{experience} (Integer) is the experience level of the user and 
\textbf{progress} (Object) is an object that will hold the progress of the user with counted questionTypes and if they where answered correctly.

\section{API Calls}
In actuality currently there exist four API calls the qr-code backend is handling.
\begin{itemize}
    \item \textbf{/connect/host} - This is the call that is used by the host to connect to the backend and receiving the JWT token.
    \item \textbf{/disconnect/all} - This call is used by the client or host to close the current session.
    \item \textbf{/private/user-data/:userId} - Here we get the private-user data from the backend, which is already stored (currently only age and experience).
    \item \textbf{/private/saveAgeAndExprience} - This call is used to save the age and experience of the user in a private session.
\end{itemize}
Adding more API calls is possible, but currently not needed.
If one shall adjust those calls then only in the matter of better verification, so that no workaround allows to use these API calls without the right to do so.